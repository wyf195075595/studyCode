<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <link rel="stylesheet" href="">
    <style type="text/css" media="screen">
        *{
            padding:0;
            margin:0;
        }
        #box1{
            width:800px;
            height:400px;
            background-color:#ccc;
            margin-left:20px;
            margin-top:10px;
            border:4px solid black;
        }
        #polygon{
            width:400px;
            height:300px;
            border:1px solid red;
        }
    </style>
</head>
<body>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="300" width='100%'>
<g style="cursor: pointe r;">
<!-- transparent || none -->
  <circle cx='100' cy='100' r='50' stroke='red' stroke-width='3' fill='transparent'/>
  <text x='100' y='108' font-size='20' text-anchor='middle'>QQ</text>
  <line x1='50' y1='50' x2='200' y2='100' stroke='#333' stroke-opacity='0.6' stroke-width='5'></line>
  <line x1='200' y1='100' x2='120' y2='140' stroke='#333' stroke-opacity='0.6' stroke-width='5'></line>
  <polyline points = '40,40,190,90,190,90,110,130' fill = 'none' stroke = '#333' stroke-width='5'></polyline>
  <polygon points = '30,30,180,80,180,80,100,120' fill = 'none' stroke = '#333' stroke-width='5'></polygon>
  <rect width='100' height='50' fill='pink' x='200' y='50' rx='10'></rect>
  <image x='100' y='200' width="100" height="100" xlink:href='bz1.jpg'></image>
  <!-- <path d='M300 100L250 150L300 200Z' stroke = 'black' stroke-width = 5 fill = 'none' /> -->
  <path d='M150 150A100 100 0 0 1 250 150L225 175A50 50 0 0 0 175 175Z  ' stroke = 'black' stroke-width = 5 fill = 'none' />

</g>
</svg>
<div id="polygon"></div>

<div id="box1"></div>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="600" width='100%' id='oSvg'></svg>
</body>
<script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js" ></script>
<script type="text/javascript" charset="utf-8" >
window.onload = function(){

    var Oparent = document.getElementById('polygon')


    var box1 = document.getElementById('box1')
    var svgNS = 'http://www.w3.org/2000/svg'

    var centerX = box1.offsetWidth/2
    var centerY = box1.offsetHeight/2
    var nodes = []
    var num = 360/40
    var centerR = 150


    for(let i = 0; i < num ;i++ ){
        var x = centerX+centerR*Math.cos(40*i*Math.PI/180)
        var y = centerY+centerR*Math.sin(40*i*Math.PI/180)
        nodes.push({x,y})
    }

    console.log(nodes)

    var data = {
        centerNode : {text:'第七班'},
        otherNode : nodes
    }

    creatMainTag()
    bindTap()
    // 创建主标签
    function creatMainTag(){
        var oSvg = createTag('svg',{xmlns:svgNS,width:'100%',height:'100%'})
        for (var i = 0; i < data.otherNode.length; i++) {
            addTag(data.otherNode[i] , oSvg)
        };


        var oCircle = createTag('circle',{cx:centerX,cy:centerY,r:60,fill:'white'})
        var oG = createTag('g',{'style':'cursor:pointer'})
        var oText = createTag('text',{x:centerX,y:centerY+8,fill:'skyblue','font-size':'20','text-anchor':'middle'})
        oText.innerHTML = data.centerNode.text
        oG.append(oCircle,oText)
        oSvg.appendChild(oG)
        console.log(oSvg)
        box1.appendChild(oSvg)
    }

    // 创建其他标签
    function addTag(attr , oSvg){
        var oG1 = createTag('g',{'style':'cursor:pointer',class:'olStyle'})
        var oG2 = createTag('g',{'style':'cursor:pointer',class:'ocStyle'})
        var oLine1 = createTag('line',{'x1':attr.x,'y1':attr.y,'x2':centerX,'y2':centerY,'stroke':'#333'})
        var oLine2 = createTag('line',{'x1':attr.x,'y1':attr.y,'x2':centerX,'y2':centerY,'stroke':'transparent'})
        var rect = createTag('rect',{'x':(attr.x + centerX)/2 -10,'y':(attr.y + centerY)/2 -10,'fill':'#333','width':'20','height':'20','rx':'5'})
        var oText1 = createTag('text',{'x':(attr.x + centerX)/2,'y':(attr.y + centerY)/2+8,'fill':'#ccc','font-size':'20','text-anchor':'middle'})
        oText1.innerHTML = '?'
        oG1.append(oLine1,oLine2,rect,oText1)
        var oCircle = createTag('circle',{cx:attr.x,cy:attr.y,r:30,fill:'white'})
        var oText2 = createTag('text',{'x':attr.x,'y':attr.y +6,'fill':'skyblue','font-size':'16','text-anchor':'middle'})
        oText2.innerHTML = '卡卡西'

        oG2.append(oCircle,oText2)
        oSvg.append(oG1,oG2)
    }
    // 动态绑定事件
    function bindTap(){
        var oL = document.getElementsByClassName('olStyle')
        var oC = document.getElementsByClassName('ocStyle')
        // console.log(oG)
        // console.log(oC)

        for(let i = 0 ; i < oL.length; i++){

            oL[i].onmouseenter = function(event) {
                // startmove(this.getElementsByTagName('circle'),30,40)
            }
            oL[i].onmouseleave= function(event) {
                // startmove(this.getElementsByTagName('circle'),40,30)
            }
            oC[i].onmouseenter = function(event) {
                startmove(this.getElementsByTagName('circle')[0],30,40)
                var prevLine = this.previousSibling
                prevLine.getElementsByTagName('line')[0].setAttribute('stroke', 'skyblue')
                prevLine.getElementsByTagName('rect')[0].setAttribute('fill', 'skyblue')
                console.log(prevLine)
            }
            oC[i].onmouseleave= function(event) {
                var prevLine = this.previousSibling
                startmove(this.getElementsByTagName('circle')[0],40,30)
                prevLine.getElementsByTagName('line')[0].setAttribute('stroke', '#333')
                prevLine.getElementsByTagName('rect')[0].setAttribute('fill', '#333')
            }
        }
    }

    // 弹性运动   1  10
    function startmove(obj,r1,r2){
        var nowR = r1,overR = r2
        obj.speed = 0  //起始速度
        clearInterval(obj.timer)
        obj.timer = setInterval(()=>{
            obj.speed += (overR - nowR)/6
            obj.speed *= 0.9
            if(Math.abs(overR - nowR)<1 && Math.abs(obj.speed)<=1 ){
                clearInterval(obj.timer)
                obj.setAttribute('r', overR)
            }else{
                nowR += obj.speed
                obj.setAttribute('r', nowR)
            }
        },30)
    }

    // 创建标签函数('标签名','属性')
    function createTag(tag,objAttr){
        var oTag = document.createElementNS(svgNS,tag)
        for(var attr in objAttr){
            oTag.setAttribute(attr, objAttr[attr])
        }
        return oTag
    }

    var Lines = null
    var pointList = ''
     // 折线
    polygons()
    function polygons(){
        var oSvg = createTag('svg',{xmlns:svgNS,width:'100%',height:'100%'})
        Oparent.append(oSvg)

        oSvg.onmousedown = (e)=>{

             var x = e.clientX - Oparent.offsetLeft
             var y = e.clientY - Oparent.offsetTop
             console.log(x,y)
            if(!Lines){
                Lines = createTag('polyline',{fill:'none',stroke:'#333','stroke-width':3})
                oSvg.append(Lines)
            }
            if(pointList == ''){
                pointList += x + ',' + y
            }else{
                pointList += ',' + x + ',' + y
            }
            console.log(pointList)
            if(oSvg.onmousemove){
                Lines.setAttribute('points',pointList)
                var oC = createTag('circle',{cx:x,cy:y,r:5,stroke:'red','stroke-width':3,fill:'white'})
                oSvg.append(oC)
            }

        }

        oSvg.onmousemove = (e)=>{

            if(Lines){
                var x = e.clientX - Oparent.offsetLeft
                var y = e.clientY - Oparent.offsetTop
                Lines.setAttribute('points',pointList + ',' + x + ',' + y)
            }

        }

        oSvg.oncontextmenu = ()=>{
            oSvg.onmousemove = null
            return false
        }

    }
    // path 参数
    // M ：开始坐标 L：后续坐标 H：水平长度 V：垂直长度 Z：路劲闭合
    //A：（x半径,y半径,角度，弧长（0小弧、1大弧），方向（0顺、1逆），终点x坐标，终点y坐标
    // circle()
    circleAnimate()
    function circle(){
        var arrNum = [15,26,31,13,15] //占比
        var arrColor = ['red','yello','skyblue','blue','green']
        var sumNum = 0  //累加占比
        var angle = 360 //角度
        var innerR = 70 //内半径
        var outerR = 120 //外半径
        var centerX = 200 //中心x轴
        var centerY = 200 //中心y轴
        var outerXY = [{x:320,y:200}] //起始坐标
        var innerXY = [{x:270,y:200}] //起始坐标
        var oSvg = document.getElementById('oSvg')


        for(var i = 0;i<arrNum.length;i++){
            var agNum = arrNum[i]/100* angle
            sumNum += agNum
            var outerX = Math.cos(sumNum*Math.PI/180)*outerR + centerX
            var outerY = Math.sin(sumNum*Math.PI/180)*outerR + centerY
            outerXY.push({x:outerX,y:outerY})

            var innerX = Math.cos(sumNum*Math.PI/180)*innerR + centerX
            var innerY = Math.sin(sumNum*Math.PI/180)*innerR + centerY
            innerXY.push({x:innerX,y:innerY})
        }

        for(let i = 0;i<innerXY.length;i++){
            if(i== outerXY.length-1){break}
            var oPath = createTag('path',{fill:arrColor[i],d:'M'+outerXY[i].x+' '+outerXY[i].y+'A'+outerR+' '+outerR+' 0 0 1 '+outerXY[i+1].x+' '+outerXY[i+1].y+'L'+innerXY[i+1].x+' '+innerXY[i+1].y+'A'+innerR +' '+innerR +' 0 0 0 '+innerXY[i].x+' '+innerXY[i].y})

            oSvg.append(oPath)
        }

        console.log(oSvg)

    }
    // 运动版
    function circleAnimate(){
        var arrNum = [15,26,31,13,15] //占比
        var arrColor = ['red','yello','skyblue','blue','green']
        var angle = 360 //角度
        var innerR = 70 //内半径
        var outerR = 120 //外半径
        var centerX = 200 //中心x轴
        var centerY = 200 //中心y轴
        var oSvg = document.getElementById('oSvg')

        $('#oSvg').animate({
            move:'auto'
        },
        {
            duration:500,
            easing:'swing',
            step:function(a,b){
                var sumNum = 0  //累加占比
                var outerXY = [{x:320,y:200}] //起始坐标
                var innerXY = [{x:270,y:200}] //起始坐标
                // b.pos 0 -> 1的运动值
                 for(var i = 0;i<arrNum.length;i++){
                    var agNum = arrNum[i]/100* angle
                    sumNum += agNum
                    var outerX = Math.cos(sumNum*b.pos*Math.PI/180)*outerR + centerX
                    var outerY = Math.sin(sumNum*b.pos*Math.PI/180)*outerR + centerY
                    outerXY.push({x:outerX,y:outerY})

                    var innerX = Math.cos(sumNum*b.pos*Math.PI/180)*innerR + centerX
                    var innerY = Math.sin(sumNum*b.pos*Math.PI/180)*innerR + centerY
                    innerXY.push({x:innerX,y:innerY})
                }

                for(let i = 0;i<innerXY.length;i++){
                    if(i== outerXY.length-1){break}
                    var oPath = createTag('path',{fill:arrColor[i],d:'M'+outerXY[i].x+' '+outerXY[i].y+'A'+outerR+' '+outerR+' 0 0 1 '+outerXY[i+1].x+' '+outerXY[i+1].y+'L'+innerXY[i+1].x+' '+innerXY[i+1].y+'A'+innerR +' '+innerR +' 0 0 0 '+innerXY[i].x+' '+innerXY[i].y})

                    oSvg.append(oPath)
                }
            }
        });



        console.log(oSvg)

    }
}



    var gp = box1.getBoundingClientRect();
    console.log(box1.getBoundingClientRect())
    // box1.offsetHeight
    console.log(getStyle(box1,'background-color'))
    console.log(getOffset(box1))


//获取元素样式
function getStyle(obj,attr){
    console.log(obj,attr)
    return obj.currentStyle?obj.currentStyle[attr]:getComputedStyle(obj)[attr]
    // return getComputedStyle(obj)[attr]
    // return obj.currentStyle[attr]
}
// 获取元素偏移量
function getOffset(ele){
    return ele.getBoundingClientRect?getOffsetRect(ele):getOffsetSum(ele)
}
// 获取相对于document的偏移量
function getOffsetRect(ele){
    var top = 0 , left = 0
    while(ele){
        top+= ele.offsetTop
        left+= ele.offsetLeft
        ele = ele.offsetParent
    }
    return {
        top : top,
        left : left
    }
}
// 获取相对视口的偏移量（viewport）加上页面的滚动量
function getOffsetRect(ele){
    var box = ele.getBoundingClientRect()
        //获取body节点
    var body = document.body,
        // 文档对象节点（html）
        docElem = document.documentElement
    // 获取页面scrollTop，scrollLeft兼容写法，(页面 水平/垂直 滚动距离)
    var scrollTop = window.pageYOffset||docElem.scrollTop||body.scrollTop,
        scrollLeft = window.pageXOffset||docElem.scrollLeft||body.scrollLeft
        // clientTop元素上边框厚度
    var clientTop = docElem.clientTop||body.clientTop,
        clientLeft = docElem.clientLeft||body.clientLeft
        // 元素距离页面高度 + 页面滚动条高度 - 元素上边框厚度
    var top = box.top + scrollTop - clientTop,
        left = box.left + scrollLeft - clientLeft
    return {
        top : Math.round(top),
        left : Math.round(left)
    }

}
</script>
</html>